%******************************************************************
%***************************给定初始条件****************************
%******************************************************************

c=5;        %聚类中心的个数
%M=2;        %固定加权指数
e=1;        %停止阈值
count=0;    %迭代次数
flag=true;  %迭代循环标志
A=0.9;

%********选取初始指定颜色R,G,B的值**********
Choose_r=[0;203;155;158;250];
Choose_g=[89;240;155;121;235];
Choose_b=[83;249;155;99;241];

%********将其转换为L,a,b的值****************
for i=1:c
    W=[0.433910 0.376220 0.189860;0.212649 0.715169 0.072182;0.017756 0.109478 0.872915]*[Choose_r(i,:)/255;Choose_g(i,:)/255;Choose_b(i,:)/255];%变换的固定公式,得到3*1的矩阵
    X=W(1,1);
    Y=W(2,1);               %X,Y,Z对应取W矩阵的每一行的值,方便以下Lab变换使用
    Z=W(3,1);               
    if(Y>0.0088556)         %Lab变换后的 L值(L范围【0，100】)
        Choose_Ly(i,1)=116*Y.^(1/3)-16;  %开三次方根程序,我在matlab里直接这样写了,老师说要用牛顿迭代公式，百度一下吧.
    else
        Choose_Ly(i,1)=903.3*Y;
    end
    Choose_ay(i,1)=500*(f(X)-f(Y));      %Lab变换后的 a值（范围【-100，+100】）
    Choose_by(i,1)=200*(f(Y)-f(Z));      %Lab变换后的 b值（范围【-100，+100】）
    
    Choose_L(i,1)=log2(Choose_Ly(i,1)/100+1);
    Choose_a(i,1)=log2((Choose_ay(i,1)+100)/200+1);
    Choose_b(i,1)=log2((Choose_by(i,1)+100)/200+1);
end

%******************************************************************
%*********************读图像并取R、G、B的值*************************
%******************************************************************

I=imread('r4.bmp');
figure('NumberTitle', 'off', 'Name', 'BCFCM');
subplot(211);imshow(I);
I=double(I);
R=I(:,:,1);
G=I(:,:,2);
B=I(:,:,3);
[m,n]=size(R);%m,n为R的行和列
%********给定初始偏移场**********
for i=1:m
    for j=1:n
        B(i,j)=0.1;
    end
end
%******************************************************************
%***********************将RGB分量Lab变换****************************
%******************************************************************
for i=1:m
    for j=1:n
        W=[0.433910 0.376220 0.189860;0.212649 0.715169 0.072182;0.017756 0.109478 0.872915]*[R(i,j)/255;G(i,j)/255;B(i,j)/255];%变换的固定公式,得到3*1的矩阵
        X=W(1,1);
        Y=W(2,1);               %X,Y,Z对应取W矩阵的每一行的值,方便以下Lab变换使用
        Z=W(3,1);               
        if(Y>0.0088556)         %Lab变换后的 L值
            Ly(i,j)=116*Y.^(1/3)-16; 
        else
            Ly(i,j)=903.3*Y;
        end
        ay(i,j)=500*(f(X)-f(Y));      %Lab变换后的 a值
        by(i,j)=200*(f(Y)-f(Z));      %Lab变换后的 b值
        
        L(i,j)=log2(Ly(i,j)/100+1);
        a(i,j)=log2((ay(i,j)+100)/200+1);
        b(i,j)=log2((by(i,j)+100)/200+1);
    end
end

%******************************************************************
%***********************在Lab空间下进行BCFCM算法********************
%******************************************************************

while(flag&&count<1000) 
    for i=2:m-1
        for j=2:n-1
            p=(i-1)*n+j;%每个像素点的位置，p表示是第几个像素点
            %**********求距离dist**********
            for k=1:c
                distL(k,p)=(Choose_L(k,1)-B(i,j)-L(i,j))*(Choose_L(k,1)-B(i,j)-L(i,j));
                dista(k,p)=(Choose_a(k,1)-B(i,j)-a(i,j))*(Choose_a(k,1)-B(i,j)-a(i,j));
                distb(k,p)=(Choose_b(k,1)-B(i,j)-b(i,j))*(Choose_b(k,1)-B(i,j)-b(i,j));

                dL(k,p)=L(i,j)-B(i,j);
                da(k,p)=a(i,j)-B(i,j);
                db(k,p)=b(i,j)-B(i,j);
                dLab(k,p)=(dL(k,p)+da(k,p)+db(k,p))/3.0;

                %若接近于灰色，主要按亮度求
                if(a(i,j)<1.555&&a(i,j)>1.445&&b(i,j)<1.555&&b(i,j)>1.445)
                    distLab(k,p)=(0.8*distL(k,p)+0.1*dista(k,p)+0.1*distb(k,p));
                %若彩色分量比较多的点，求平均
                else
                    distLab(k,p)=(distL(k,p)+dista(k,p)+distb(k,p))/3.0;
                end
            end
        end
    end
    for i=2:m-1
        for j=2:n-1
            p=(i-1)*n+j;
            for k=1:c
                R(k,p)=0;
                R1(k,p)=0;
                for t1=1:3
                    for t2=1:3
                        R(k,p)=R(k,p)+distLab(k,p+t2-2+(t1-2)*n);
                        R1(k,p)=R1(k,p)+dLab(k,p+t2-2+(t1-2)*n);
                    end
                end
            end
            %**********求隶属度LabU**********
            Sum_dist=0;
            for k=1:c
                Sum_dist=Sum_dist+(1/(distLab(k,p)+A/9*R(k,p)));
            end
            for k=1:c
                LabU(k,p)=(1/(distLab(k,p)-A/9*R(k,p)))*(1/Sum_dist);
            end
        end
    end

    %*********求变换后的聚类中心矩阵V**********
    for k=1:c
        VL=0;
        Va=0;
        Vb=0;
        V=0;
        for i=2:m-1
            for j=2:n-1
                p=(i-1)*n+j;%每个像素点的位置，p表示是第几个像素点
                VL=VL+LabU(k,p)*LabU(k,p)*(L(i,j)-B(i,j)+A/9.0*R1(k,p));
                Va=Va+LabU(k,p)*LabU(k,p)*(a(i,j)-B(i,j)+A/9.0*R1(k,p));
                Vb=Vb+LabU(k,p)*LabU(k,p)*(b(i,j)-B(i,j)+A/9.0*R1(k,p));
                V =V +LabU(k,p)*LabU(k,p);
            end
        end
        Old_L(k,1)=Choose_L(k,1);
        Old_a(k,1)=Choose_a(k,1);   %先将原来的聚类中心点保存在Old中
        Old_b(k,1)=Choose_b(k,1);

        Choose_L(k,1)=VL/V/(1+A);
        Choose_a(k,1)=Va/V/(1+A);         %新的聚类中心点
        Choose_b(k,1)=Vb/V/(1+A);
    end
    
    %*********求变换后新的偏移场B**********
    for i=2:m-1
        for j=2:n-1
            p=(i-1)*n+j;
            BL1=0;
            Ba1=0;
            Bb1=0;
            B1=0;
            for k=1:c
                BL1=BL1+LabU(k,p)^2*Choose_L(k,1);
                Ba1=Ba1+LabU(k,p)^2*Choose_a(k,1);
                Bb1=Bb1+LabU(k,p)^2*Choose_b(k,1);
                B1=B1+LabU(k,p)^2;
            end
            BL(i,j)=L(i,j)-BL1/B1;
            Ba(i,j)=a(i,j)-Ba1/B1;
            Bb(i,j)=b(i,j)-Bb1/B1;
            B(i,j)=(Bl(i,j)+Ba(i,j)+Bb(i,j))/3.0;
        end
    end
    flag=false;
    for k=1:c
        if(abs(Choose_L1(k,1)-Old_L(k,1))>e||abs(Choose_a1(k,1)-Old_a(k,1))>e||abs(Choose_b1(k,1)-Old_b(k,1))>e)
            count=count+1;
            flag=true;
            break;
        end
    end
end

%******************************************************************
%**********************将Choose_L,a,b取反对数***********************
%******************************************************************
for k=1:c
    Choose_L1(k,1)=(2^Choose_L(k,1)-1)*100;
    Choose_a1(k,1)=(2^Choose_a(k,1)-1)*200-100;
    Choose_b1(k,1)=(2^Choose_b(k,1)-1)*200-100;
end

%******************************************************************
%*********************将Choose_L,a,b变换为R,G,B*********************
%******************************************************************
for i=1:c
    fy = (Choose_L1(i,1)+16.0)/116.0;
    fy = fy*fy*fy;
    
    if(fy > 0.008856)
        y=fy;
    else
        fy = Choose_L1(i,1)/903.3;
    end
    
    if(fy > 0.008856)
        fy = fy.^(1.0/3.0);
    else
        fy = 7.787*fy+16.0/116.0;
    end
    
    fx = Choose_a1(i,1)/500.0 + fy;
    if(fx > 0.206893)
        x = fx.^3.0;
    else
        x = (fx-16.0/116.0)/7.787;
    end
    
    fz = fy - Choose_b1(i,1)/200.0;
    if(fz > 0.206893)
        z = fz.^3;
    else
        z = (fz-16.0/116.0)/7.787;
    end
    
    x = x*0.950456*255.0;
    y = y*255.0;
    z = z*1.088754*255.0;

    r(i,1) =  3.240479*x  - 1.537150*y - 0.498535*z;
    g(i,1) =  -0.969256*x + 1.875992*y + 0.041556*z;
    b(i,1) =  0.055648*x  - 0.204043*y + 1.057311*z;
end

%******************************************************************
%***********************按聚类中心分割图像显示***********************
%******************************************************************
for i=1:m
    for j=1:n
        for k=1:c
            rr(k)=abs(R(i,j)-r(k,1));
            gg(k)=abs(G(i,j)-g(k,1));
            bb(k)=abs(B(i,j)-b(k,1));
            e(k)=1/3*(rr(k)+gg(k)+bb(k));
        end%令图像的每一个像素点分别与c种参考色求误差，用于识别其属于哪种参考色
        p=1;
        for k=1:c-1
            if(e(p)>e(k+1))
                p=k+1;
            else
                p=p;
            end
        end%此for循环用于判断像素点与c种颜色中哪种颜色误差最小
        R(i,j)=r(p,1);
        G(i,j)=g(p,1);
        B(i,j)=b(p,1);%将该像素点替换为误差最小的参考色
     
        I(i,j,1)=R(i,j);
        I(i,j,2)=G(i,j);
        I(i,j,3)=B(i,j);%将替换后得到的RGB的值合成图像
    end
end
I1=uint8(I);
subplot(212);imshow(I1);